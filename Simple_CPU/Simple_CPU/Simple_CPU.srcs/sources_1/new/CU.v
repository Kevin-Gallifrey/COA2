`timescale 1ns / 1ps
//////////////////////////////////////////////////////////////////////////////////
// Company: 
// Engineer: 
// 
// Create Date: 2020/04/23 15:09:16
// Design Name: 
// Module Name: CU
// Project Name: 
// Target Devices: 
// Tool Versions: 
// Description: 
// 
// Dependencies: 
// 
// Revision:
// Revision 0.01 - File Created
// Additional Comments:
// 
//////////////////////////////////////////////////////////////////////////////////


module CU(
    input clk,
    input rst,
    input [2:0] flag,
    input [7:0] IR,
    output  [18:0] C,
    output  [3:0] OP
    );
    
    //  control memory
    (*dont_touch = "true" *) reg [22:0] CM [0:100];
    //CM[][22:19]=Op[3:0] CM[][18:0]=C18~C0
    
	parameter idle=0, decode=1, fetch=2, run=3;
	reg [1:0] step=0;
	(*dont_touch = "true" *) reg [7:0] CAR=0;
	reg [22:0] CBR=0;
    reg halt = 1;
    
    
     assign OP = CBR[22:19];
     assign C = CBR[18:0];
     
    always@(posedge clk or negedge rst)
	begin
        if(~rst)
            begin
                step <= idle;
                halt <=0;
                //初始化CM
                
                //Fetch Instruction
                CM[0]=23'b00000000000010000000001;
                CM[1]=23'b00000000000000000001001;
                CM[2]=23'b00000000000000000010001;
                CM[3]=23'b00000000000000001000010;
                //STORE X
                CM[4]=23'b00000000000000000100001;
                CM[5]=23'b00000000000100000000001;
                CM[6]=23'b00000000001000000000100;
                //LOAD [X]
                CM[7]=23'b00000000000000000100001;
                CM[8]=23'b00000000000000000001001;
                CM[9]=23'b00000000000000110000001;
                CM[10]=23'b01100001100000000000001;
                CM[11]=23'b00000010000000000000100;
                //ADD [X]
                CM[12]=23'b00000000000000000100001;
                CM[13]=23'b00000000000000000001001;
                CM[14]=23'b00000000000000010000001;
                CM[15]=23'b00010001100000000000001;
                CM[16]=23'b00000010000000000000100;
                //SUB [X]
                CM[17]=23'b00000000000000000100001;
                CM[18]=23'b00000000000000000001001;
                CM[19]=23'b00000000000000010000001;
                CM[20]=23'b00100001100000000000001;
                CM[21]=23'b00000010000000000000100;
                //JMPGEZ X(ACC<0)
                CM[22]=23'b00000000000000000000100;
                //JMP X & JMPGEZ X(ACC>0)
                CM[23]=23'b00000000010000000000100;
                //HALT
                CM[24]=23'b00000000000000000000000;
                //MPY [X]
                CM[25]=23'b00000000000000000100001;
                CM[26]=23'b00000000000000000001001;
                CM[27]=23'b00000000000000010000001;
                CM[28]=23'b00110001100000000000001;
                CM[29]=23'b00000010000000000000100;
                //DIV [X]
                CM[30]=23'b00000000000000000100001;
                CM[31]=23'b00000000000000000001001;
                CM[32]=23'b00000000000000010000001;
                CM[33]=23'b01000001100000000000001;
                CM[34]=23'b00000010000000000000100;
                //AND [X]
                CM[35]=23'b00000000000000000100001;
                CM[36]=23'b00000000000000000001001;
                CM[37]=23'b00000000000000010000001;
                CM[38]=23'b01010001100000000000001;
                CM[39]=23'b00000010000000000000100;
                //OR [X]
                CM[40]=23'b00000000000000000100001;
                CM[41]=23'b00000000000000000001001;
                CM[42]=23'b00000000000000010000001;
                CM[43]=23'b01100001100000000000001;
                CM[44]=23'b00000010000000000000100;
                //XOR [X]
                CM[45]=23'b00000000000000000100001;
                CM[46]=23'b00000000000000000001001;
                CM[47]=23'b00000000000000010000001;
                CM[48]=23'b01110001100000000000001;
                CM[49]=23'b00000010000000000000100;
                //NOT [X]
                CM[50]=23'b00000000000000000100001;
                CM[51]=23'b00000000000000000001001;
                CM[52]=23'b00000000000000010000001;
                CM[53]=23'b10000000100000000000001;
                CM[54]=23'b00000010000000000000100;
                //SHIFTR
                CM[55]=23'b10010001000000000000001;
                CM[56]=23'b00000010000000000000100;
                //SHIFTL
                CM[57]=23'b10100001000000000000001;
                CM[58]=23'b00000010000000000000100;
                //LOAD X
                CM[59]=23'b00000000000000110000001;
                CM[60]=23'b00000000000001000000001;
                CM[61]=23'b01100001100000000000001;
                CM[62]=23'b00000010000000000000100;
                //ADD X
                CM[63]=23'b00000000000000010000001;
                CM[64]=23'b00000000000001000000001;
                CM[65]=23'b00010001100000000000001;
                CM[66]=23'b00000010000000000000100;
                //SUB X
                CM[67]=23'b00000000000000010000001;
                CM[68]=23'b00000000000001000000001;
                CM[69]=23'b00100001100000000000001;
                CM[70]=23'b00000010000000000000100;
                //MPY X
                CM[71]=23'b00000000000000010000001;
                CM[72]=23'b00000000000001000000001;
                CM[73]=23'b00110001100000000000001;
                CM[74]=23'b00000010000000000000100;
                //DIV X
                CM[75]=23'b00000000000000010000001;
                CM[76]=23'b00000000000001000000001;
                CM[77]=23'b01000001100000000000001;
                CM[78]=23'b00000010000000000000100;
                //AND X
                CM[79]=23'b00000000000000010000001;
                CM[80]=23'b00000000000001000000001;
                CM[81]=23'b01010001100000000000001;
                CM[82]=23'b00000010000000000000100;
                //OR X
                CM[83]=23'b00000000000000010000001;
                CM[84]=23'b00000000000001000000001;
                CM[85]=23'b01100001100000000000001;
                CM[86]=23'b00000010000000000000100;
                //XOR X
                CM[87]=23'b00000000000000010000001;
                CM[88]=23'b00000000000001000000001;
                CM[89]=23'b01110001100000000000001;
                CM[90]=23'b00000010000000000000100;
                //NOT X
                CM[91]=23'b10110001000000000000001;
                CM[92]=23'b00000010000000000000100;
                //CM[93]=23'b10000001100000000000001;
                //CM[94]=23'b00000010000000000000100;
                //STOREMR X
                CM[95]=23'b00000000000000000100001;
                CM[96]=23'b00000100000000000000001;
                CM[97]=23'b00000000001000000000100;	
	//STOREDR X
                CM[98]=23'b00000000000000000100001;
                CM[99]=23'b00001000000000000000001;
                CM[100]=23'b00000000001000000000100;
            end
        else
        begin
            case(step)
                idle:begin
                     if(~halt)
                           begin
                                CAR <= 0;
                                CBR <= 0;
                                step <= fetch;
                            end
                     else step <= idle;
           end
                //译码，由IR得到CM中微指令的地址?
                decode:begin
                    case(IR)
                                        8'b0000_0001:begin    //STORE X
                                            CAR <= 4;
                                            step <= fetch;
                                        end
                                        8'b0000_0010:begin    //LOAD [X]
                                            CAR <= 7;
                                            step <= fetch;
                                        end
                                        8'b0000_0011:begin    //ADD [X]
                                            CAR <= 12;
                                            step <= fetch;
                                        end
                                        8'b0000_0100:begin    //SUB [X]
                                            CAR <= 17;
                                            step <= fetch;
                                        end
                                        8'b0000_0101:begin    //JMPGEZ X(ACC<0)
                                        if(flag[1])
                                            CAR <= 23;
                                        else
                                             CAR <= 99;
                                        step <= fetch;
                                        end
                                        8'b0000_0110:begin    //JMP X & JMPGEZ X(ACC>0)    
                                        if((flag[1]==0)&&(flag[2]==0))
                                            CAR <= 23;
                                        else
                                            CAR <= 99;
                                        step <= fetch;
                                        end
                                        8'b0000_0111:begin    //HALT    
                                            CAR <= 24;
                                            step <= fetch;
                                            halt <=1;
                                        end
                                        8'b0000_1000:begin    //MPY [X]    
                                            CAR <= 25;
                                            step <= fetch;
                                        end
                                        8'b0000_1001:begin    //DIV [X]
                                            CAR <= 30;
                                            step <= fetch;
                                        end
                                        8'b0000_1010:begin    //AND [X]    
                                            CAR <= 35;
                                            step <= fetch;
                                        end
                                        8'b0000_1011:begin    //OR [X]    
                                            CAR <= 40;
                                            step <= fetch;
                                        end
                                        8'b0000_1100:begin    //XOR [X]    
                                            CAR <= 45;
                                            step <= fetch;
                                        end
                                        8'b0000_1101:begin    //NOT [X]    
                                            CAR <= 50;
                                            step <= fetch;
                                        end
                                        8'b0000_1110:begin    //SHIFTR    
                                            CAR <= 55;
                                            step <= fetch;
                                        end
                                        8'b0000_1111:begin    //SHIFTL    
                                            CAR <= 57;
                                            step <= fetch;
                                        end
                                        8'b0001_0000:begin    //LOAD X    
                                            CAR <= 59;
                                            step <= fetch;
                                        end
                                        8'b0001_0001:begin    //ADD X    
                                            CAR <= 63;
                                            step <= fetch;
                                        end
                                        8'b0001_0010:begin    //SUB X    
                                            CAR <= 67;
                                            step <= fetch;
                                        end
                                        8'b0001_0011:begin    //MPY X    
                                            CAR <= 71;
                                            step <= fetch;
                                        end
                                        8'b0001_0100:begin    //DIV X
                                            CAR <= 75;
                                            step <= fetch;
                                        end
                                        8'b0001_0101:begin    //AND X
                                            CAR <= 79;
                                            step <= fetch;
                                        end
                                        8'b0001_0110:begin    //OR X    
                                            CAR <= 83;
                                            step <= fetch;
                                        end
                                        8'b0001_0111:begin    //XOR X
                                            CAR <= 87;
                                            step <= fetch;
                                        end
                                        8'b0001_1000:begin    //NOT X    
                                            CAR <= 91;
                                            step <= fetch;
                                        end
                                        8'b0001_1001:begin    //STOREMR X    
                                            CAR <= 95;
                                            step <= fetch;
                                        end
                                        8'b0001_1010:begin    //STOREDR X    
                                            CAR <= 98;
                                            step <= fetch;
                                        end
                        default: 
                        begin
                            step <= idle;	//没有有效指令，返回idle
                            halt <= 1;
                        end
                    endcase
                end
                //取指令，根据CAR取出微指令到CBR
                fetch:begin
                    CBR <= CM[CAR];
                    step <= run;
                end
                //运行微指令，输出控制信号并得到下一条微指令的地址?
                run:begin
                    CBR <= 0;
                    case(CBR[2:0])
                        3'b001:begin
                            CAR <= CAR + 1;
                            step <= fetch;
                        end
                        3'b010:begin
                            step <= decode;
                        end
                        3'b100:begin
                            CAR <= 0;
                            step <= fetch;
                        end
                        default:begin
                            step <= idle;
                        end
                    endcase
                end
                
            endcase
        end
    end
	
endmodule